[
  {
    "id": 1,
    "title": "useBattery",
    "description": "Custom hook to retrieve battery information and status.",
    "content": "import { useState, useEffect } from \"react\";\n\nconst description = \"Custom hook to retrieve battery information and status.\";\n\ninterface BatteryManager {\n  level: number;\n  charging: boolean;\n  chargingTime: number;\n  dischargingTime: number;\n  addEventListener(\n    type: string,\n    listener: EventListener | EventListenerObject | null,\n    options?: boolean | AddEventListenerOptions,\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: EventListener | EventListenerObject | null,\n    options?: boolean | EventListenerOptions,\n  ): void;\n}\n\ninterface BatteryState {\n  supported: boolean;\n  loading: boolean;\n  level: number | null;\n  charging: boolean | null;\n  chargingTime: number | null;\n  dischargingTime: number | null;\n}\n\ninterface NavigatorWithBattery extends Navigator {\n  getBattery?: () => Promise<BatteryManager>;\n}\n\n/**\n * Custom hook to retrieve battery information and status.\n *\n * @description Provides battery information including level, charging status, and estimated time for charging and discharging.\n * Handles unsupported environments by setting `supported` to `false`.\n *\n * @returns {BatteryState} - An object with battery state properties:\n * - `supported` {boolean}: Indicates if the Battery API is supported.\n * - `loading` {boolean}: True while fetching initial battery data.\n * - `level` {number | null}: Battery level as a decimal (0.0 to 1.0), or null if unavailable.\n * - `charging` {boolean | null}: Whether the battery is currently charging, or null if unavailable.\n * - `chargingTime` {number | null}: Estimated time in seconds until fully charged, or null if unavailable.\n * - `dischargingTime` {number | null}: Estimated time in seconds until battery is depleted, or null if unavailable.\n */\nexport function useBattery() {\n  const [batteryState, setBatteryState] = useState<BatteryState>({\n    supported: true,\n    loading: true,\n    level: null,\n    charging: null,\n    chargingTime: null,\n    dischargingTime: null,\n  });\n\n  useEffect(() => {\n    const _navigator = navigator as NavigatorWithBattery;\n    let battery: BatteryManager | null = null;\n\n    /**\n     * Updates the battery state when a battery property changes.\n     */\n    const handleBatteryChange = () => {\n      if (battery) {\n        setBatteryState({\n          supported: true,\n          loading: false,\n          level: battery.level,\n          charging: battery.charging,\n          chargingTime: battery.chargingTime,\n          dischargingTime: battery.dischargingTime,\n        });\n      }\n    };\n\n    if (!_navigator.getBattery) {\n      setBatteryState((prevState) => ({\n        ...prevState,\n        supported: false,\n        loading: false,\n      }));\n      return;\n    }\n\n    _navigator\n      .getBattery()\n      .then((_battery) => {\n        battery = _battery;\n        handleBatteryChange();\n        battery.addEventListener(\"levelchange\", handleBatteryChange);\n        battery.addEventListener(\"chargingchange\", handleBatteryChange);\n        battery.addEventListener(\"chargingtimechange\", handleBatteryChange);\n        battery.addEventListener(\"dischargingtimechange\", handleBatteryChange);\n      })\n      .catch(() => {\n        setBatteryState((prevState) => ({\n          ...prevState,\n          supported: false,\n          loading: false,\n        }));\n      });\n\n    return () => {\n      if (battery) {\n        battery.removeEventListener(\"levelchange\", handleBatteryChange);\n        battery.removeEventListener(\"chargingchange\", handleBatteryChange);\n        battery.removeEventListener(\"chargingtimechange\", handleBatteryChange);\n        battery.removeEventListener(\n          \"dischargingtimechange\",\n          handleBatteryChange,\n        );\n      }\n    };\n  }, []);\n\n  return batteryState;\n}\n"
  },
  {
    "id": 2,
    "title": "useClipboard",
    "description": "A hook that provides a function to copy text to the clipboard.",
    "content": "import { useState, useEffect } from \"react\";\n\nconst description =\n  \"A hook that provides a function to copy text to the clipboard.\";\n\n/**\n * React hook to copy a given text to the user's clipboard.\n *\n * @param {number} [timeout=1500] Time in milliseconds to show the \"copied\"\n * success state after a successful copy action.\n *\n * @returns {object} An object with two properties:\n * - `isCopied`: A boolean indicating whether the text was successfully copied\n *   to the user's clipboard.\n * - `copy`: A function that takes a string argument and attempts to copy it to\n *   the user's clipboard. If the copy action is successful, it sets the\n *   `isCopied` state to `true`.\n */\nexport function useClipboard(timeout: number = 1500) {\n  const [isCopied, setIsCopied] = useState(false);\n\n  useEffect(() => {\n    let timer: ReturnType<typeof setTimeout>;\n\n    if (isCopied) {\n      timer = setTimeout(() => {\n        setIsCopied(false);\n      }, timeout);\n    }\n\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [isCopied, timeout]);\n\n  /**\n   * Attempts to copy the given text to the user's clipboard.\n   *\n   * If the copy action is successful, it sets the `isCopied` state to `true`.\n   * If the copy action fails, it logs an error to the console and\n   * displays a native alert with the message \"Failed to copy text\".\n   *\n   * If the browser does not support the Clipboard API, it displays a\n   * native alert with the message \"Copy not supported\".\n   *\n   * @param {string} text The text to copy to the user's clipboard.\n   */\n  const copy = (text: string) => {\n    if (navigator.clipboard && window.isSecureContext) {\n      navigator.clipboard\n        .writeText(text)\n        .then(() => {\n          setIsCopied(true);\n        })\n        .catch((err) => {\n          console.error(\"Failed to copy: \", err);\n          alert(\"Failed to copy text\");\n        });\n    } else {\n      alert(\"Copy not supported\");\n    }\n  };\n\n  return { isCopied, copy };\n}\n"
  },
  {
    "id": 3,
    "title": "useCountDown",
    "description": "Custom hook that implements a countdown functionality.",
    "content": "import { useCallback, useState, useEffect } from \"react\";\n\nconst description = \"Custom hook that implements a countdown functionality.\";\n\ntype CountdownOptions = {\n  countStart: number;\n  intervalMs?: number;\n  countStop?: number;\n};\n\ntype CountdownControllers = {\n  startCountdown: () => void;\n  stopCountdown: () => void;\n  resetCountdown: () => void;\n};\n\n/**\n * Custom hook that implements a countdown functionality.\n *\n * @param {CountdownOptions} options - The options for the countdown.\n * @param {number} options.countStart - The starting count value.\n * @param {number} [options.countStop=0] - The count value at which the countdown stops.\n * @param {number} [options.intervalMs=1000] - The interval in milliseconds at which the countdown updates.\n * @returns {[number, CountdownControllers]} - A tuple containing the current count and countdown controllers.\n */\nexport function useCountdown({\n  countStart,\n  countStop = 0,\n  intervalMs = 1000,\n}: CountdownOptions): [number, CountdownControllers] {\n  const [count, setCount] = useState(countStart);\n  const [isRunning, setIsRunning] = useState(false);\n  const [timer, setTimer] = useState<ReturnType<typeof setInterval> | null>(\n    null,\n  );\n\n  const startCountdown = useCallback(() => {\n    if (!isRunning) {\n      setIsRunning(true);\n    }\n  }, [isRunning]);\n\n  const stopCountdown = useCallback(() => {\n    if (timer) {\n      clearInterval(timer);\n      setTimer(null);\n    }\n    setIsRunning(false);\n  }, [timer]);\n\n  const resetCountdown = useCallback(() => {\n    stopCountdown();\n    setCount(countStart);\n  }, [stopCountdown, countStart]);\n\n  useEffect(() => {\n    if (isRunning) {\n      setTimer(\n        setInterval(() => {\n          setCount((prevCount) => {\n            if (prevCount <= countStop) {\n              stopCountdown();\n              return countStop;\n            }\n            return prevCount - 1;\n          });\n        }, intervalMs),\n      );\n    }\n\n    return () => {\n      if (timer) {\n        clearInterval(timer);\n      }\n    };\n  }, [isRunning, intervalMs, countStop, stopCountdown]);\n\n  return [count, { startCountdown, stopCountdown, resetCountdown }];\n}\n"
  },
  {
    "id": 4,
    "title": "useCountUp",
    "description": "Custom hook that implements a count-up functionality.",
    "content": "import { useCallback, useState, useEffect } from \"react\";\n\nconst description = \"Custom hook that implements a count-up functionality.\";\n\ntype CountupOptions = {\n  countStart: number;\n  intervalMs?: number;\n  countStop?: number;\n};\n\ntype CountupControllers = {\n  startCountup: () => void;\n  stopCountup: () => void;\n  resetCountup: () => void;\n};\n\n/**\n * Custom hook that implements a count-up functionality.\n *\n * @param {CountupOptions} options - The options for the count-up.\n * @param {number} options.countStart - The starting count value.\n * @param {number} [options.countStop=Infinity] - The count value at which the count-up stops.\n * @param {number} [options.intervalMs=1000] - The interval in milliseconds at which the count-up updates.\n * @returns {[number, CountupControllers]} - A tuple containing the current count and count-up controllers.\n */\nexport function useCountup({\n  countStart,\n  countStop = Infinity,\n  intervalMs = 1000,\n}: CountupOptions): [number, CountupControllers] {\n  const [count, setCount] = useState(countStart);\n  const [isRunning, setIsRunning] = useState(false);\n  const [timer, setTimer] = useState<ReturnType<typeof setInterval> | null>(\n    null,\n  );\n\n  const startCountup = useCallback(() => {\n    if (!isRunning) {\n      setIsRunning(true);\n    }\n  }, [isRunning]);\n\n  const stopCountup = useCallback(() => {\n    if (timer) {\n      clearInterval(timer);\n      setTimer(null);\n    }\n    setIsRunning(false);\n  }, [timer]);\n\n  const resetCountup = useCallback(() => {\n    stopCountup();\n    setCount(countStart);\n  }, [stopCountup, countStart]);\n\n  useEffect(() => {\n    if (isRunning) {\n      setTimer(\n        setInterval(() => {\n          setCount((prevCount) => {\n            if (prevCount >= countStop) {\n              stopCountup();\n              return countStop;\n            }\n            return prevCount + 1;\n          });\n        }, intervalMs),\n      );\n    }\n\n    return () => {\n      if (timer) {\n        clearInterval(timer);\n      }\n    };\n  }, [isRunning, intervalMs, countStop, stopCountup]);\n\n  return [count, { startCountup, stopCountup, resetCountup }];\n}\n"
  },
  {
    "id": 5,
    "title": "useCounter",
    "description": "Hook that returns a tuple containing increment, decrement, reset functions, and the current value of the counter.",
    "content": "import {\n  useCallback,\n  useState,\n  type SetStateAction,\n  type Dispatch,\n} from \"react\";\n\ntype CounterReturnType = {\n  increment: () => void;\n  decrement: () => void;\n  reset: () => void;\n  count: number;\n  setCount: Dispatch<SetStateAction<number>>;\n};\n\nconst description =\n  \"Hook that returns a tuple containing increment, decrement, reset functions, and the current value of the counter.\";\n\n/**\n * Hook that returns a tuple containing the following:\n * - `increment`: A function that increments the counter by 1.\n * - `decrement`: A function that decrements the counter by 1.\n * - `reset`: A function that sets the counter to 0.\n * - `count`: The current value of the counter.\n * - `setCount`: A state setter function that sets the counter to the given\n *   value.\n *\n * The hook takes an optional `initialValue` parameter which sets the initial\n * value of the counter. If not provided, the counter is initialized to 0.\n *\n * @param {number} [initialValue] Optional initial value of the counter.\n * @returns {CounterReturnType}\n */\nexport function useCounter(initialValue?: number): CounterReturnType {\n  const [count, setCount] = useState(initialValue ?? 0);\n\n  const increment = useCallback(() => setCount((x) => x + 1), []);\n  const decrement = useCallback(() => setCount((x) => x - 1), []);\n  const reset = useCallback(() => {\n    setCount(initialValue ?? 0);\n  }, [initialValue]);\n\n  return {\n    increment,\n    decrement,\n    reset,\n    count,\n    setCount,\n  };\n}\n"
  },
  {
    "id": 6,
    "title": "useDebounceCallback",
    "description": "Custom hook that debounces a callback function, executing it after the specified delay.",
    "content": "import { useCallback, useEffect, useRef } from \"react\";\n\nconst description =\n  \"Custom hook that debounces a callback function, executing it after the specified delay.\";\n\n/**\n * Custom hook that debounces a callback function, executing it after the specified delay.\n *\n * @param {Function} callback - The callback function to debounce.\n * @param {number} delay - The debounce delay in milliseconds.\n * @returns {Function} - A debounced version of the callback function.\n *\n * @example\n * const debouncedSave = useDebounceCallback((value) => {\n *   console.log(\"Saving data:\", value);\n * }, 500);\n */\nexport function useDebounceCallback<T extends (...args: any[]) => void>(\n  callback: T,\n  delay: number,\n): (...args: Parameters<T>) => void {\n  const timer = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  const debouncedCallback = useCallback(\n    (...args: Parameters<T>) => {\n      if (timer.current) {\n        clearTimeout(timer.current);\n      }\n\n      timer.current = setTimeout(() => {\n        callback(...args);\n      }, delay);\n    },\n    [callback, delay],\n  );\n\n  useEffect(() => {\n    return () => {\n      if (timer.current) {\n        clearTimeout(timer.current);\n      }\n    };\n  }, []);\n\n  return debouncedCallback;\n}\n"
  },
  {
    "id": 7,
    "title": "useDebounceValue",
    "description": "Custom hook that debounces a value, returning the value after the specified delay.",
    "content": "import { useEffect, useState } from \"react\";\n\nconst description =\n  \"Custom hook that debounces a value, returning the value after the specified delay.\";\n\n/**\n * Custom hook that debounces a value, returning the value after the specified delay.\n * Useful for cases where you want to prevent frequent updates (e.g., input fields).\n *\n * @template T - The type of the value being debounced.\n * @param {T} value - The value to debounce.\n * @param {number} delay - The debounce delay in milliseconds.\n * @returns {T} - The debounced value.\n *\n * @example\n * const debouncedSearchTerm = useDebounceValue(searchTerm, 500);\n * // The debouncedSearchTerm will update 500ms after the last change in searchTerm.\n */\nexport function useDebounceValue<T>(value: T, delay: number): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n"
  },
  {
    "id": 8,
    "title": "useDevice",
    "description": "A hook that detects the device type and returns a boolean value for each device type.",
    "content": "import { useEffect, useState } from \"react\";\n\nexport interface DeviceDetect {\n  isMobile: boolean;\n  isDesktop: boolean;\n  isTablet: boolean;\n  DesktopView: () => boolean;\n  MobileView: () => boolean;\n  TabletView: () => boolean;\n}\n\nconst description =\n  \"A hook that detects the device type and returns a boolean value for each device type.\";\n\n/**\n * A hook that detects the device type and returns a boolean value for each device type.\n *\n * @returns {DeviceDetect} - An object containing boolean values for each device type.\n */\nexport function useDevice(): DeviceDetect {\n  const [deviceType, setDeviceType] = useState<string | null>(null);\n\n  useEffect(() => {\n    const userAgent = navigator.userAgent;\n\n    if (/tablet/i.test(userAgent)) {\n      setDeviceType(\"tablet\");\n    } else if (/mobile/i.test(userAgent)) {\n      setDeviceType(\"mobile\");\n    } else {\n      setDeviceType(\"desktop\");\n    }\n  }, []);\n\n  const isMobile = deviceType === \"mobile\";\n  const isDesktop = deviceType === \"desktop\";\n  const isTablet = deviceType === \"tablet\";\n\n  const DesktopView = () => isDesktop;\n  const MobileView = () => isMobile;\n  const TabletView = () => isTablet;\n\n  return {\n    isMobile,\n    isDesktop,\n    isTablet,\n    DesktopView,\n    MobileView,\n    TabletView,\n  };\n}\n"
  },
  {
    "id": 9,
    "title": "useEventCallback",
    "description": "A hook that returns a memoized version of a callback that is stable between renders.",
    "content": "import { useRef, useEffect, useCallback } from \"react\";\n\nconst description =\n  \"A hook that returns a memoized version of a callback that is stable between renders.\";\n\n/**\n * A hook that returns a memoized version of a callback that is stable between renders.\n *\n * @param fn The callback function that depends on external values.\n * @returns A stable version of the provided callback.\n */\nexport function useEventCallback<T extends (...args: any[]) => any>(fn: T): T {\n  const ref = useRef<T>(fn);\n\n  useEffect(() => {\n    ref.current = fn;\n  }, [fn]);\n\n  return useCallback(((...args) => ref.current(...args)) as T, []);\n}\n"
  },
  {
    "id": 10,
    "title": "useEventListener",
    "description": "A custom hook to add and clean up an event listener on any target element.",
    "content": "import { useEffect, useRef, type RefObject } from \"react\";\n\nconst description =\n  \"A custom hook to add and clean up an event listener on any target element.\";\n\n/**\n * A custom hook to add and clean up an event listener on any target element.\n *\n * @param eventName The event type (e.g. 'click', 'scroll', 'resize', etc.).\n * @param handler The event handler function.\n * @param element Optional: The target element to attach the event listener to (defaults to window).\n */\nexport function useEventListener<K extends keyof WindowEventMap>(\n  eventName: K,\n  handler: (event: WindowEventMap[K]) => void,\n  element?: RefObject<HTMLElement> | Window,\n): void {\n  const savedHandler = useRef<(event: WindowEventMap[K]) => void>(handler);\n\n  // Update the ref.current value if the handler changes\n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    const targetElement: HTMLElement | Window =\n      element && \"current\" in element ? element.current! : window;\n\n    if (!targetElement) return;\n\n    // Type assertion is added here to ensure TypeScript understands the event type correctly\n    const eventListener: EventListener = (event) =>\n      savedHandler.current(event as WindowEventMap[K]);\n\n    targetElement.addEventListener(eventName, eventListener);\n\n    return () => {\n      targetElement.removeEventListener(eventName, eventListener);\n    };\n  }, [eventName, element]);\n}\n"
  },
  {
    "id": 11,
    "title": "useFetch",
    "description": "Custom hook to fetch data from an API endpoint.",
    "content": "import { useState, useEffect, useCallback } from \"react\";\n\ninterface UseFetchResult<T, E> {\n  data: T | null;\n  error: E | null;\n  isPending: boolean;\n  isSuccess: boolean;\n  isError: boolean;\n  refetch: () => void;\n}\n\nconst description = \"Custom hook to fetch data from an API endpoint.\";\n\n/**\n * Custom hook to fetch data from an API endpoint.\n *\n * @template T - Type of the data returned by the API.\n * @template E - Type of the error returned by the API (default is `string`).\n *\n * @param {string} url - The URL of the API endpoint.\n * @param {RequestInit} [reqOpt] - Optional configuration for the fetch request (e.g., method, headers).\n *\n * @returns {UseFetchResult<T, E>} An object containing the following properties:\n * - `data`: The data returned by the API, or `null` if no data has been received yet.\n * - `error`: The error returned by the API, or `null` if no error has occurred.\n * - `isPending`: A boolean indicating whether the fetch request is currently in progress.\n * - `isSuccess`: A boolean indicating if the fetch request was successful.\n * - `isError`: A boolean indicating if the fetch request resulted in an error.\n * - `refetch`: A function to manually trigger the fetch request again.\n */\nexport function useFetch<T, E = string>(\n  url: string,\n  reqOpt?: RequestInit,\n): UseFetchResult<T, E> {\n  const [data, setData] = useState<T | null>(null);\n  const [error, setError] = useState<E | null>(null);\n  const [isPending, setisPending] = useState(false);\n  const [isSuccess, setIsSuccess] = useState(false);\n\n  /**\n   * Fetches data from the provided URL using the specified request options.\n   *\n   * This function uses `fetch` with an `AbortController` to allow for request cancellation if needed.\n   * Updates the state with the response data, error, or loading status based on the fetch result.\n   */\n  const fetchData = useCallback(async () => {\n    setisPending(true);\n    setIsSuccess(false);\n\n    const controller = new AbortController();\n    const signal = controller.signal;\n\n    try {\n      const res = await fetch(url, { ...reqOpt, signal });\n      const result = await res.json();\n\n      if (res.ok) {\n        setData(result);\n        setIsSuccess(true);\n        setError(null);\n      } else {\n        setError(result as E);\n      }\n    } catch (e) {\n      if (e instanceof Error && e.name !== \"AbortError\") {\n        setError(e as unknown as E);\n      }\n    } finally {\n      setisPending(false);\n    }\n\n    return () => controller.abort();\n  }, [url, reqOpt]);\n\n  useEffect(() => {\n    fetchData();\n  }, []);\n\n  return {\n    data,\n    error,\n    isPending,\n    isSuccess,\n    isError: !isSuccess && !isPending,\n    refetch: fetchData,\n  };\n}\n"
  },
  {
    "id": 12,
    "title": "useFocus",
    "description": "A custom hook to track whether an element is focused.",
    "content": "import { useEffect, useRef, useState, type RefObject } from \"react\";\n\ntype UseFocusCallback = (isFocused: boolean) => void;\n\nconst description = \"A custom hook to track whether an element is focused.\";\n\n/**\n * Returns a ref and boolean indicating whether the element is currently focused.\n *\n * Optionally takes a callback function which is called whenever the element\n * gains or loses focus. The callback is called with a boolean indicating\n * whether the element is currently focused.\n *\n * @param callback Optional callback to run in focus and blur HTML element mode\n * @returns A tuple containing the ref and a boolean indicating whether the\n * element is currently focused.\n */\nexport function useFocus<T extends HTMLElement>(\n  callback?: UseFocusCallback,\n): [RefObject<T>, boolean] {\n  const [isFocused, setIsFocused] = useState(false);\n  const ref = useRef<T>(null);\n\n  useEffect(() => {\n    /**\n     * A function to run whenever the element gains focus.\n     * @param {boolean} isFocused - Whether the element is currently focused.\n     * @param {UseFocusCallback} [callback] - The callback function provided to useFocus.\n     */\n    const handleFocus = () => {\n      setIsFocused(true);\n      callback?.(true);\n    };\n    /**\n     * A function to run whenever the element loses focus.\n     * @param {boolean} isFocused - Whether the element is currently focused.\n     * @param {UseFocusCallback} [callback] - The callback function provided to useFocus.\n     */\n    const handleBlur = () => {\n      setIsFocused(false);\n      callback?.(false);\n    };\n\n    const node = ref.current;\n    if (node) {\n      node.addEventListener(\"focus\", handleFocus);\n      node.addEventListener(\"blur\", handleBlur);\n    }\n\n    return () => {\n      if (node) {\n        node.removeEventListener(\"focus\", handleFocus);\n        node.removeEventListener(\"blur\", handleBlur);\n      }\n    };\n  }, [callback]);\n\n  return [ref, isFocused];\n}\n"
  },
  {
    "id": 13,
    "title": "useHover",
    "description": "A custom hook to track whether an element is hovered.",
    "content": "import { useState, useRef, useEffect } from \"react\";\n\nconst description = \"A custom hook to track whether an element is hovered.\";\n\n/**\n * Adds an event listener to a given target.\n *\n * @param eventType - The type of event to listen for.\n * @param listener - The event handler function.\n * @param target - The target to which the event listener will be attached.\n */\nfunction useEventListener<K extends keyof HTMLElementEventMap>(\n  eventType: K,\n  listener: (this: HTMLElement, ev: HTMLElementEventMap[K]) => any,\n  target: React.RefObject<HTMLElement>,\n): void {\n  useEffect(() => {\n    const element = target.current;\n    if (!element) return;\n\n    element.addEventListener(eventType, listener);\n    return () => element.removeEventListener(eventType, listener);\n  }, [eventType, listener, target]);\n}\n\n/**\n * A custom hook to track whether an element is hovered.\n *\n * @returns A tuple containing a ref to attach to the element and a boolean indicating if it's hovered.\n */\nexport function useHover<T extends HTMLElement>(): [\n  React.RefObject<T>,\n  boolean,\n] {\n  const [isHovered, setIsHovered] = useState(false);\n  const ref = useRef<T>(null);\n\n  const handleMouseEnter = () => setIsHovered(true);\n  const handleMouseLeave = () => setIsHovered(false);\n\n  useEventListener(\"mouseenter\", handleMouseEnter, ref);\n  useEventListener(\"mouseleave\", handleMouseLeave, ref);\n\n  return [ref, isHovered];\n}\n"
  },
  {
    "id": 14,
    "title": "useIsClient",
    "description": "Custom hook that determines if the component is being rendered on the client side.",
    "content": "import { useEffect, useState } from \"react\";\n\nconst description =\n  \"Custom hook that determines if the component is being rendered on the client side.\";\n\n/**\n * A custom React hook that determines if the component is being rendered on the client side.\n *\n * @returns {boolean} - Returns true if the component is mounted on the client, false otherwise.\n */\nexport function useIsClient(): boolean {\n  const [isClient, setClient] = useState<boolean>(false);\n\n  useEffect(() => {\n    setClient(true);\n  }, []);\n\n  return isClient;\n}\n"
  },
  {
    "id": 15,
    "title": "useIsMounted",
    "description": "Custom React hook that returns a function to check if the component is currently mounted.",
    "content": "import { useEffect, useRef } from \"react\";\n\nconst description =\n  \"Custom React hook that returns a function to check if the component is currently mounted.\";\n\ntype UseIsMountedReturnType = () => boolean;\n\n/**\n * A custom React hook that returns a function to check if the component is currently mounted.\n *\n * This hook can be useful for preventing state updates on unmounted components,\n * which can lead to memory leaks and errors in your application.\n *\n * @returns {Function} A function that returns a boolean indicating whether the component is mounted.\n */\nexport function useIsMounted(): UseIsMountedReturnType {\n  const isMounted = useRef<boolean>(false);\n\n  useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return () => isMounted.current;\n}\n"
  },
  {
    "id": 16,
    "title": "useKeyPress",
    "description": "Custom hook to detect if a specified key is pressed.",
    "content": "import { useState, useEffect } from \"react\";\n\ninterface KeyConfig {\n  key: string;\n  ctrl?: boolean;\n  alt?: boolean;\n  shift?: boolean;\n  meta?: boolean;\n}\n\nconst description = \"Custom hook to detect if a specified key is pressed.\";\n\n/**\n * Key configuration object for the useKeyPress hook.\n *\n * @typedef {Object} KeyConfig\n * @property {string} key - The key to listen for.\n * @property {boolean} [ctrl] - Whether the Ctrl key must be pressed. Optional.\n * @property {boolean} [alt] - Whether the Alt key must be pressed. Optional.\n * @property {boolean} [shift] - Whether the Shift key must be pressed. Optional.\n */\n\n/**\n * Custom hook to detect if a specified key is pressed.\n *\n * @param {KeyConfig} config - The configuration for the key press detection.\n * @returns {boolean} - A boolean value indicating whether the specified key combination is currently pressed.\n *\n * @example\n * // Usage:\n * const isEnterPressed = useKeyPress({ key: \"Enter\" });\n * const isCtrlSPressed = useKeyPress({ key: \"s\", ctrl: true });\n */\n\nexport function useKeyPress(config: KeyConfig): boolean {\n  const [keyPressed, setKeyPressed] = useState(false);\n  const { key: targetKey, ctrl, alt, shift, meta } = config;\n\n  const handleKeyDown = (e: KeyboardEvent) => {\n    const { key, ctrlKey, altKey, shiftKey, metaKey } = e;\n\n    if (\n      (!ctrl && !alt && !shift && key === targetKey) ||\n      (ctrl && key === targetKey && ctrlKey === ctrl) ||\n      (alt && key === targetKey && altKey === alt) ||\n      (shift && key === targetKey && shiftKey === shift) ||\n      (meta && key === targetKey && metaKey === meta)\n    ) {\n      setKeyPressed(true);\n    }\n  };\n\n  const handleKeyUp = (e: KeyboardEvent) => {\n    const { key, ctrlKey, altKey, shiftKey, metaKey } = e;\n\n    if (\n      (!ctrl && !alt && !shift && key === targetKey) ||\n      (ctrl && key === targetKey && ctrlKey === ctrl) ||\n      (alt && key === targetKey && altKey === alt) ||\n      (shift && key === targetKey && shiftKey === shift) ||\n      (meta && key === targetKey && metaKey === meta)\n    ) {\n      setKeyPressed(false);\n    }\n  };\n\n  useEffect(() => {\n    window.addEventListener(\"keydown\", handleKeyDown);\n    window.addEventListener(\"keyup\", handleKeyUp);\n\n    return () => {\n      window.removeEventListener(\"keydown\", handleKeyDown);\n      window.removeEventListener(\"keyup\", handleKeyUp);\n    };\n  }, []);\n\n  return keyPressed;\n}\n"
  },
  {
    "id": 17,
    "title": "useLang",
    "description": "Custom hook that returns the current language of the user's browser, based on their browser settings.",
    "content": "import { useSyncExternalStore } from \"react\";\n\nconst description =\n  \"Custom hook that returns the current language of the user's browser, based on their browser settings.\";\n\n/**\n * Subscribes to the `languagechange` event on the `window` object to detect changes in the user's preferred language.\n * This function returns an unsubscribe function to remove the event listener.\n *\n * @param {() => void} callback - The callback function that triggers when the language changes.\n * @returns {() => void} A function to unsubscribe from the `languagechange` event.\n */\nfunction langSubscribe(callback: () => void) {\n  window.addEventListener(\"languagechange\", callback);\n  return () => window.removeEventListener(\"languagechange\", callback);\n}\n\n/**\n * Retrieves the current language of the user's browser.\n *\n * @returns {string} The current language code (e.g., 'en-US', 'fr', etc.).\n */\nconst getLang = (): string => navigator.language;\n\n/**\n * Custom hook that returns the current language of the user's browser, automatically updating when the language changes.\n *\n * @returns {string} The current browser language.\n */\nexport function useLang(): string {\n  return useSyncExternalStore(langSubscribe, getLang);\n}\n"
  },
  {
    "id": 18,
    "title": "useLocalStorage",
    "description": "Custom hook that manages a state variable with local storage.",
    "content": "import { useState, useEffect } from \"react\";\n\nconst description =\n  \"Custom hook that manages a state variable with local storage.\";\n\n/**\n * Custom hook that manages a state variable with local storage.\n *\n * @param {string} key - The key for the local storage item.\n * @param {T} initialValue - The initial value for the state variable.\n * @returns {[T, (value: T) => void]} An array containing the state variable and a setter function.\n *\n * @example\n * const [name, setName] = useLocalStorage('name', 'John Doe');\n * // The name variable will be persisted in local storage under the key 'name'.\n */\nexport function useLocalStorage<T>(\n  key: string,\n  initialValue: T,\n): [T, (value: T) => void] {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(`Error reading local storage key \"${key}\":`, error);\n      return initialValue;\n    }\n  });\n\n  const setValue = (value: T) => {\n    try {\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      setStoredValue(valueToStore);\n      window.localStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting local storage key \"${key}\":`, error);\n    }\n  };\n\n  useEffect(() => {\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.key === key) {\n        setStoredValue(\n          event.newValue ? JSON.parse(event.newValue) : initialValue,\n        );\n      }\n    };\n\n    window.addEventListener(\"storage\", handleStorageChange);\n\n    return () => {\n      window.removeEventListener(\"storage\", handleStorageChange);\n    };\n  }, [key, initialValue]);\n\n  return [storedValue, setValue];\n}\n"
  },
  {
    "id": 19,
    "title": "useOnlineStatus",
    "description": "Custom hook that returns the current online/offline status of the browser.",
    "content": "import { useState, useEffect } from \"react\";\n\nconst description =\n  \"Custom hook that returns the current online/offline status of the browser.\";\n\n/**\n * Custom hook that returns the current online/offline status of the browser.\n * Optionally, takes a callback function to be invoked whenever the status changes.\n *\n * @param {function} callback - Optional callback to run on status change.\n * @returns {boolean} - `true` if online, `false` if offline.\n */\nexport function useOnlineStatus(\n  callback?: (isOnline: boolean) => void,\n): boolean {\n  const [isOnline, setIsOnline] = useState(navigator.onLine);\n\n  useEffect(() => {\n    const handleOnline = () => {\n      setIsOnline(true);\n      if (callback) callback(true);\n    };\n\n    const handleOffline = () => {\n      setIsOnline(false);\n      if (callback) callback(false);\n    };\n\n    window.addEventListener(\"online\", handleOnline);\n    window.addEventListener(\"offline\", handleOffline);\n\n    return () => {\n      window.removeEventListener(\"online\", handleOnline);\n      window.removeEventListener(\"offline\", handleOffline);\n    };\n  }, [callback]);\n\n  return isOnline;\n}\n"
  },
  {
    "id": 20,
    "title": "useScroll",
    "description": "Custom hook that tracks and returns the current scroll position, and provides a method to scroll to specific coordinates.",
    "content": "import { useState, useLayoutEffect } from \"react\";\n\nconst description =\n  \"Custom hook that tracks and returns the current scroll position, and provides a method to scroll to specific coordinates.\";\n\n/**\n * Represents the scroll position in the x and y directions.\n */\ntype ScrollPosition = {\n  x: number;\n  y: number;\n};\n\n/**\n * Custom hook that tracks and returns the current scroll position,\n * and provides a method to scroll to specific coordinates.\n *\n * @returns {{ position: ScrollPosition; scrollTo: (options: ScrollToOptions) => void }}\n */\nexport function useScroll(): {\n  position: ScrollPosition;\n  scrollTo: (options: ScrollToOptions) => void;\n} {\n  const [position, setPosition] = useState<ScrollPosition>({\n    x: 0,\n    y: 0,\n  });\n\n  const handleScroll = () => {\n    if (typeof window !== \"undefined\") {\n      setPosition({\n        x: window.scrollX,\n        y: window.scrollY,\n      });\n    }\n  };\n\n  useLayoutEffect(() => {\n    if (typeof window !== \"undefined\") {\n      setPosition({\n        x: window.scrollX,\n        y: window.scrollY,\n      });\n\n      window.addEventListener(\"scroll\", handleScroll);\n\n      return () => {\n        window.removeEventListener(\"scroll\", handleScroll);\n      };\n    }\n  }, []);\n\n  const scrollTo = (options: ScrollToOptions) => {\n    if (typeof window !== \"undefined\") {\n      window.scrollTo(options);\n    }\n  };\n\n  return {\n    position,\n    scrollTo,\n  };\n}\n"
  },
  {
    "id": 21,
    "title": "useSessionStorage",
    "description": "Custom hook that manages a state variable with session storage.",
    "content": "import { useState, useEffect } from \"react\";\n\nconst description =\n  \"Custom hook that manages a state variable with session storage.\";\n\n/**\n * Custom hook that manages a state variable with session storage.\n *\n * @param {string} key - The key for the session storage item.\n * @param {T} initialValue - The initial value for the state variable.\n * @returns {[T, (value: T) => void]} An array containing the state variable and a setter function.\n *\n * @example\n * const [name, setName] = useSessionStorage('name', 'John Doe');\n * // The name variable will be persisted in session storage under the key 'name'.\n */\nexport function useSessionStorage<T>(\n  key: string,\n  initialValue: T,\n): [T, (value: T) => void] {\n  const [storedValue, setStoredValue] = useState<T>(() => {\n    try {\n      const item = window.sessionStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      console.error(`Error reading session storage key \"${key}\":`, error);\n      return initialValue;\n    }\n  });\n\n  const setValue = (value: T) => {\n    try {\n      const valueToStore =\n        value instanceof Function ? value(storedValue) : value;\n      setStoredValue(valueToStore);\n      window.sessionStorage.setItem(key, JSON.stringify(valueToStore));\n    } catch (error) {\n      console.error(`Error setting session storage key \"${key}\":`, error);\n    }\n  };\n\n  useEffect(() => {\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.key === key) {\n        setStoredValue(\n          event.newValue ? JSON.parse(event.newValue) : initialValue,\n        );\n      }\n    };\n\n    window.addEventListener(\"storage\", handleStorageChange);\n\n    return () => {\n      window.removeEventListener(\"storage\", handleStorageChange);\n    };\n  }, [key, initialValue]);\n\n  return [storedValue, setValue];\n}\n"
  },
  {
    "id": 22,
    "title": "useThrottle",
    "description": "Custom React hook that returns a throttled version of the provided function.",
    "content": "import { useCallback, useRef, useEffect } from \"react\";\n\nconst description =\n  \"Custom React hook that returns a throttled version of the provided function.\";\n\n/**\n * Interface for throttle options\n * @interface ThrottleOptions\n * @property {number} [wait=300] - The number of milliseconds to throttle invocations to\n * @property {boolean} [leading=true] - Specify invoking on the leading edge of the timeout\n * @property {boolean} [trailing=true] - Specify invoking on the trailing edge of the timeout\n */\ninterface ThrottleOptions {\n  wait?: number;\n  leading?: boolean;\n  trailing?: boolean;\n}\n\n/**\n * Custom React hook that returns a throttled version of the provided function.\n * The throttled function will only execute at most once per every `wait` milliseconds.\n *\n * @template T - Generic type extending function\n * @param {T} fn - The function to throttle\n * @param {ThrottleOptions} [options] - The configuration options\n * @param {number} [options.wait=300] - The number of milliseconds to throttle invocations to\n * @param {boolean} [options.leading=true] - If true, the function will execute on the leading edge of the timeout\n * @param {boolean} [options.trailing=true] - If true, the function will execute on the trailing edge of the timeout\n *\n * @returns {(...args: Parameters<T>) => void} A throttled version of the provided function\n */\nexport function useThrottle<T extends (...args: any[]) => any>(\n  fn: T,\n  options: ThrottleOptions = {},\n): (...args: Parameters<T>) => void {\n  const { wait = 300, leading = true, trailing = true } = options;\n\n  const timeoutRef = useRef<number | null>(null);\n  const lastRunRef = useRef<number>(0);\n  const lastArgsRef = useRef<Parameters<T> | null>(null);\n\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current !== null) {\n        window.clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  return useCallback(\n    (...args: Parameters<T>) => {\n      const now = Date.now();\n      const elapsed = now - lastRunRef.current;\n\n      lastArgsRef.current = args;\n\n      const execute = () => {\n        fn(...(lastArgsRef.current as Parameters<T>));\n        lastRunRef.current = Date.now();\n      };\n\n      if (timeoutRef.current !== null) {\n        window.clearTimeout(timeoutRef.current);\n        timeoutRef.current = null;\n      }\n\n      if (elapsed > wait) {\n        if (leading) {\n          execute();\n        } else if (trailing) {\n          timeoutRef.current = window.setTimeout(execute, wait);\n        }\n      } else if (trailing) {\n        timeoutRef.current = window.setTimeout(execute, wait - elapsed);\n      }\n    },\n    [fn, wait, leading, trailing],\n  );\n}\n"
  },
  {
    "id": 23,
    "title": "useTitle",
    "description": "Custom hook to change the page title.",
    "content": "import { useState } from \"react\";\n\nconst description = \"Custom hook to change the page title.\";\n\n/**\n * Custom hook to change the page title.\n *\n * @description Provides a stateful title and a function to update both the state and the document title.\n *\n * @returns {Object} - An object containing:\n * - `title` {string}: The current page title.\n * - `changeTitle` {(newTitle: string) => void}: Function to update the page title.\n */\n\nexport function useTitle() {\n  const [title, setTitle] = useState<string>(document.title);\n\n  /**\n   * Updates the document title and internal title state.\n   *\n   * @param {string} newTitle - The new title to set for the page.\n   */\n  const changeTitle = (newTitle: string) => {\n    setTitle(newTitle);\n    document.title = newTitle;\n  };\n\n  return { title, changeTitle };\n}\n"
  },
  {
    "id": 24,
    "title": "useToggle",
    "description": "Returns a stateful value and two functions to update it.",
    "content": "import {\n  useState,\n  useCallback,\n  type Dispatch,\n  type SetStateAction,\n} from \"react\";\n\nconst description = \"Returns a stateful value and two functions to update it.\";\n\n/**\n * Returns a stateful value and two functions to update it.\n *\n * @param defaultValue - The initial value of the state. Defaults to `false`.\n *\n * @returns A tuple containing:\n * - `boolean`: The current value of the state.\n * - `() => void`: A function to toggle the state.\n * - `Dispatch<SetStateAction<boolean>>`: A function to set the state to a new value.\n */\nexport function useToggle(\n  defaultValue?: boolean,\n): [boolean, () => void, Dispatch<SetStateAction<boolean>>] {\n  const [value, setValue] = useState(!!defaultValue);\n\n  const toggle = useCallback(() => {\n    setValue((x) => !x);\n  }, []);\n\n  return [value, toggle, setValue];\n}\n"
  },
  {
    "id": 25,
    "title": "useUnmount",
    "description": "A custom React hook that executes a callback function when the component unmounts.",
    "content": "import { useEffect, useRef } from \"react\";\n\nconst description =\n  \"A custom React hook that executes a callback function when the component unmounts.\";\n\n/**\n * A custom React hook that executes a callback function when the component unmounts.\n *\n * @param {() => void} fn - The callback function to be executed on unmount.\n */\nexport function useUnmount(fn: () => void): void {\n  const fnRef = useRef<() => void>(fn);\n\n  useEffect(() => {\n    fnRef.current = fn;\n\n    return () => {\n      fnRef.current();\n    };\n  }, [fn]);\n}\n"
  },
  {
    "id": 26,
    "title": "useWindowSize",
    "description": "Custom hook that tracks and returns the current window size.",
    "content": "import { useState, useEffect } from \"react\";\n\ntype WindowSize = {\n  width: number;\n  height: number;\n};\n\nconst description =\n  \"Custom hook that tracks and returns the current window size.\";\n\n/**\n * Custom hook that tracks and returns the current window size.\n * @returns {WindowSize} An object containing the current width and height of the window.\n */\nexport function useWindowSize(): WindowSize {\n  const [windowSize, setWindowSize] = useState<WindowSize>({\n    width: window.innerWidth,\n    height: window.innerHeight,\n  });\n\n  const handleResize = () => {\n    setWindowSize({\n      width: window.innerWidth,\n      height: window.innerHeight,\n    });\n  };\n\n  useEffect(() => {\n    window.addEventListener(\"resize\", handleResize);\n\n    return () => window.removeEventListener(\"resize\", handleResize);\n  }, []);\n\n  return windowSize;\n}\n"
  }
]